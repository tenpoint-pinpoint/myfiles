par(width = 10, height = 10)
biplot(result)
window(width = 10, height = 10)
windows(width = 10, height = 10)
par(ps = 18)
biplot(result)
par(ps = 6)
biplot(result)
par(ps = 9)
biplot(result)
par(ps = 8)
biplot(result)
install.packages("corrplot")
# ヒートマップをかくためのパッケージの読み込み
# install.packages("corrplot")
library(corrplot)
dat <- read.csv("./data/mtcars_numeric.csv",
fileEncoding = "utf-8",
row.names = "model")
corrplot(dat)
dat
dat <- read.csv("./data/mtcars_numeric.csv",
fileEncoding = "utf-8",
row.names = "model")
cormat <- cor(dat)    # 相関行列の計算
corrplot(cormat)    # ヒートマップの作成
?prcomp
result <- prcomp(dat, scale. = TRUE, rank. = 2)
result
result <- prcomp(dat, scale. = TRUE, rank. = 2)    # rankは使う主成分の数
result
3*var(1/sqrt(2),1/sqrt(2),-1/sqrt(2),-1/sqrt(2))/4
3*var(c(1/sqrt(2),1/sqrt(2),-1/sqrt(2),-1/sqrt(2))/4
)
3*var(c(1/sqrt(2),1/sqrt(2),-1/sqrt(2),-1/sqrt(2)))/4
3*var(c(1,1,0,0))/4
?varimax
x <- matrix(c(1/sqrt(2), 1/sqrt(2),
1/sqrt(2), 1/sqrt(2),
1/sqrt(2), -1/sqrt(2),
1/sqrt(2), -1/sqrt(2)), ncol = 2)
x
varimax(x)
x <- matrix(c(1/2, 1/2,
1/2, 1/2,
1/2, -1/2,
1/2, -1/2), ncol = 2)
varimax(x)
x <- matrix(c(1, 0,
1, 0,
0, 1,
0, 1), ncol = 2)
varimax(x)
varimax
x <- matrix(c(3/4, 1/2,
1/2, 1/2,
3/4, 0,
1/2, 0), ncol = 2)
varimax(x)
x <- matrix(c(3/4, 1/2,
1/2, -1/2,
3/4, 0,
1/2, 0), ncol = 2)
varimax(x)
print(varimax(x), cutoff = 0)
x
x <- matrix(c(3/4, 1/2,
1/2, -1/2,
3/4, 0,
1/2, 0), ncol = 2, byrow = TRUE)
x
varimax(x)
x <- matrix(c(1/2, 1/2,
1/2, 1/2,
1/2, -1/2,
1/2, -1/2), ncol = 2, byrow = TRUE)
varimax(x)
x <- matrix(c(3/4, 2/4,
2/4, 2/4,
3/4, -2/4,
3/4, -2/4), ncol = 2, byrow = TRUE)
varimax(x)
# 正規化して分散の和を求める
rowSum(x^2)
# 正規化して分散の和を求める
rowSums(x^2)
# 正規化して分散の和を求める
rowSums(x^2)
div <- matrix(c(rowSums(x^2), rowSums(x^2)), ncol = 2)
div
x_scaled
x_scaled <- x^2/div
x_scaled
apply(x_scaled, 1, var)
apply(x_scaled, 2, var)
sum(apply(x_scaled, 2, var))
# 因子負荷行列の例 : 単純構造の場合の例
x <- varimax(x)
x
print(x, cutoff = 0)
# 正規化して分散の和を求める
rowSums(x^2)
div <- matrix(c(rowSums(x^2), rowSums(x^2)), ncol = 2)
# 正規化して分散の和を求める
x <- x$loadings
rowSums(x^2)
div <- matrix(c(rowSums(x^2), rowSums(x^2)), ncol = 2)
div
x_scaled <- x^2/div
x_scaled
apply(x_scaled, 2, var)
sum(apply(x_scaled, 2, var))
print(x_scaled, cutoff = 0)
apply(x_scaled, 2, var)
sum(apply(x_scaled, 2, var))
?varimax
varimax
(7.7-7.06)^2 + (6.6-7.18)^2 + (7-7.3)^2 + (7.2-7.42)^2 + (8.0-7.54)^2
5*(log(1.10)+log(2*pi/5)+1) + 2*(1+2)
5*(log(0.17)+log(2*pi/5)+1) + 2*(2+2)
setwd("~/Desktop/すうがくぶんか/法人さま/シスメックスさま/copula")
# データの読み込み
dat <- read.csv("./data/wine3.csv")
head(dat, n = 5)
# 基礎統計量
str(dat)    # dim(dat)
summary(dat)
cor(dat)
plot(dat)
# 経験累積分布関数の計算
udat <- dat
for (i in 1:3) {
udat[ , i] <- rank(dat[ , i]) / (1599+1)
}
# 2変量コピュラによる分解
library(VineCopula)
# acf vs acv
# 注意 : 教科書で言うところのPCC1と名前がついている構成では、このコピュラをを用いない。
BiCopKDE(udat[ , 1], udat[ , 2])
# acf vs acv
# 注意 : 教科書で言うところのPCC1と名前がついている構成では、このコピュラをを用いない。
BiCopKDE(udat[ , 1], udat[ , 2])
cor(dat$acf, dat$acv, method = "kendall")
theta_acfacv <- BiCopTau2Par(34,    # 34 : rotated Gumbel 270
cor(dat$acf, dat$acv, method = "kendall"))
#BiCopEst(u1 = udat[ , 1], u2 = udat[ , 2], family = 34, method = "itau")
#BiCopEst(u1 = udat[ , 1], u2 = udat[ , 2], family = 34, method = "mle")
obj <- BiCop(family = 34, par = theta_acfacv)
contour(obj)
# acf vs acc
BiCopKDE(udat[ , 1], udat[ , 3])
cor(dat$acf, dat$acc, method = "kendall")
theta_acfacc <- BiCopTau2Par(4,    # 4 : Gumbel
cor(dat$acf, dat$acc, method = "kendall"))
#BiCopEst(u1 = udat[ , 1], u2 = udat[ , 3], family = 4, method = "itau")
#BiCopEst(u1 = udat[ , 1], u2 = udat[ , 3], family = 4, method = "mle")
obj <- BiCop(family = 4, par = theta_acfacc)
contour(obj)
# acv vs acc
BiCopKDE(udat[ , 2], udat[ , 3])
cor(dat$acv, dat$acc, method = "kendall")
theta_acvacc <- BiCopTau2Par(5,    # 5 : Frank
cor(dat$acv, dat$acc, method = "kendall"))
obj <- BiCop(family = 5, par = theta.acvacc)
contour(obj)
# acv vs acc
BiCopKDE(udat[ , 2], udat[ , 3])
cor(dat$acv, dat$acc, method = "kendall")
theta_acvacc <- BiCopTau2Par(5,    # 5 : Frank
cor(dat$acv, dat$acc, method = "kendall"))
obj <- BiCop(family = 5, par = theta.acvacc)
obj <- BiCop(family = 5, par = theta_acvacc)
contour(obj)
# acf vs acv, given by acc
h13 <- BiCopHfunc(udat[ , 1], udat[ , 3],
family = 4, par = theta_acfacc)$hfunc2
h23 <- BiCopHfunc(udat[ , 2], udat[ , 3],
family = 5, par = theta_acvacc)$hfunc2
head(data.frame(h13, h23), n = 5)
summary(data.frame(h13, h23))
BiCopKDE(h13, h23)
cor(h13, h23, method = "kendall")
theta_12_3 <- BiCopTau2Par(1, cor(h13, h23, method = "kendall"))
obj <- BiCop(family = 1, par = theta_12_3)
contour(obj)
RVineStructureSelect(data = udat,
type = "CVine",    # "RVine"でもできる。
treecrit = "tau",
selectioncrit = "AIC",
method = "mle")
result <- RVineStructureSelect(data = udat,
type = "CVine",    # "RVine"でもできる。
treecrit = "tau",
selectioncrit = "AIC",
method = "mle")
result
summary(result)
result <- RVineStructureSelect(data = udat,
type = "RVine",
treecrit = "tau",
selectioncrit = "AIC",
method = "mle")
summary(result)
result <- RVineStructureSelect(data = udat,
treecrit = "tau",
selectioncrit = "AIC",
method = "itau")
familyset <- c(0, 1, 2, 3, 4, 5, 13, 14, 23, 24, 33, 34)
result <- RVineStructureSelect(data = udat,
familyset = familyset
treecrit = "tau",
selectioncrit = "AIC",
method = "itau")
result <- RVineStructureSelect(data = udat,
familyset = familyset,
treecrit = "tau",
selectioncrit = "AIC",
method = "itau")
summary(result)
result <- RVineStructureSelect(data = udat,
#familyset = familyset,
treecrit = "tau",
selectioncrit = "AIC",
method = "itau")
summary(result)
result <- RVineStructureSelect(data = udat,
#familyset = familyset,
treecrit = "tau",
selectioncrit = "AIC",
method = "mle")
summary(result)
# モデル選択
familyset <- c(0, 1, 2, 3, 4, 5, 13, 14, 23, 24, 33, 34)
result <- RVineStructureSelect(data = udat,
familyset = familyset,
treecrit = "tau",
selectioncrit = "AIC",
method = "itau")
summary(result)
result <- RVineStructureSelect(data = udat,
familyset = familyset,
treecrit = "tau",
selectioncrit = "AIC",
method = "mle")
summary(result)
result <- RVineStructureSelect(data = udat,
familyset = familyset,
treecrit = "tau",
selectioncrit = "AIC",
method = "itau")
summary(result)
# データの読み込み
dat <- read.csv("./data/flowcytometry.csv")
head(dat, n = 5)
# 基礎統計量
str(dat)    # dim(dat)
summary(dat)
cor(dat)
plot(dat)
# 経験累積分布関数の計算
udat <- dat
for (i in 1:4) {
udat[ , i] <- rank(dat[ , i]) / (1599+1)
}
# 経験累積分布関数の計算
udat <- dat
for (i in 1:4) {
udat[ , i] <- rank(dat[ , i]) / (17532+1)
}
# 2変量コピュラによる分解
library(VineCopula)
plot(udat)
plot(udat)
head(udat)
summary(dat)
# 2変量コピュラによる分解
library(VineCopula)
# 周辺コピュラ : acf vs acv
BiCopKDE(udat[ , 1], udat[ , 2])
cor(dat$acf, dat$acv, method = "kendall")
# モデル選択
#familyset <- c(0, 1, 2, 3, 4, 5, 13, 14, 23, 24, 33, 34)
result <- RVineStructureSelect(data = udat,
#familyset = familyset,
treecrit = "tau",
selectioncrit = "AIC",
method = "mle")
summary(result)
plot(result)
contour(result)
# データの読み込み
dat <- read.csv("./data/wine3.csv")
head(dat, n = 5)
# 基礎統計量
str(dat)    # dim(dat)
summary(dat)
cor(dat)
plot(dat)
# 経験累積分布関数の計算
udat <- dat
for (i in 1:3) {
udat[ , i] <- rank(dat[ , i]) / (1599+1)
}
# 2変量コピュラによる分解
library(VineCopula)
# 周辺コピュラ : acf vs acv
BiCopKDE(udat[ , 1], udat[ , 2])
cor(dat$acf, dat$acv, method = "kendall")
theta_acfacv <- BiCopTau2Par(34,    # 34 : rotated Gumbel 270
cor(dat$acf, dat$acv, method = "kendall"))
#BiCopEst(u1 = udat[ , 1], u2 = udat[ , 2], family = 34, method = "itau")
#BiCopEst(u1 = udat[ , 1], u2 = udat[ , 2], family = 34, method = "mle")
obj <- BiCop(family = 34, par = theta_acfacv)
contour(obj)
# 周辺コピュラ : acf vs acc
BiCopKDE(udat[ , 1], udat[ , 3])
cor(dat$acf, dat$acc, method = "kendall")
theta_acfacc <- BiCopTau2Par(4,    # 4 : Gumbel
cor(dat$acf, dat$acc, method = "kendall"))
#BiCopEst(u1 = udat[ , 1], u2 = udat[ , 3], family = 4, method = "itau")
#BiCopEst(u1 = udat[ , 1], u2 = udat[ , 3], family = 4, method = "mle")
obj <- BiCop(family = 4, par = theta_acfacc)
contour(obj)
# 周辺コピュラ : acv vs acc
BiCopKDE(udat[ , 2], udat[ , 3])
cor(dat$acv, dat$acc, method = "kendall")
theta_acvacc <- BiCopTau2Par(5,    # 5 : Frank
cor(dat$acv, dat$acc, method = "kendall"))
obj <- BiCop(family = 5, par = theta_acvacc)
contour(obj)
# 条件付きコピュラ : acf vs acv, given by acc
h13 <- BiCopHfunc(udat[ , 1], udat[ , 3],
family = 4, par = theta_acfacc)$hfunc2
h23 <- BiCopHfunc(udat[ , 2], udat[ , 3],
family = 5, par = theta_acvacc)$hfunc2
head(data.frame(h13, h23), n = 5)
summary(data.frame(h13, h23))
BiCopKDE(h13, h23)
cor(h13, h23, method = "kendall")
theta_12_3 <- BiCopTau2Par(1, cor(h13, h23, method = "kendall"))
obj <- BiCop(family = 1, par = theta_12_3)
contour(obj)
# モデル選択
familyset <- c(0, 1, 2, 3, 4, 5, 13, 14, 23, 24, 33, 34)
result <- RVineStructureSelect(data = udat,
familyset = familyset,
treecrit = "tau",
selectioncrit = "AIC",
method = "itau")
summary(result, edge.labels = "family-tau")
contour(result)
# シミュレーション
# シミュレーション
sim <- RVineSim(N = 1000, RVM = result)
sim
plot(sim)
sim <- data.frame(sim)
plot(sim)
plot(udat)
par(mfrow = c(2, 1))
plot(udat, main = "original")
plot(sim, main = "simulation")
par(mfrow = c(2, 1))
plot(udat, main = "original")
plot(sim, main = "simulation")
par(mfrow = c(2, 1))
plot(udat)
plot(sim)
plot(udat)
plot(sim)
# 必要なパッケージの読み込み
library(GGally)
ggpairs(dat)
ggpairs(udat)
ggpairs(udat)
ggpairs(sim)    # 0付近の値のシミュレーションに弱い。
pchisq(q = 0.95, df = 5)
pchisq(q = 0.05, df = 5)
pchisq(q = 0.95, df = 5)
# 必要なライブラリのロード
library(cluster)
library(dendextend)
# 必要なライブラリのロード
library(cluster)
library(dendextend)
dat <- read.csv("./data/dairy_products.csv",
fileEncoding = "utf-8",     # WindowsではUTF-8-BOM
row.names = "country")
head(dat, n = 5)
plot(dat)
# k-means法の計算
result <- kmeans(x = dat, metric = "euclidian",method = "ward")
# k-means法の計算
result <- kmeans(x = dat, metric = "euclidian",method = "ward")
# k-means法の計算
result <- agnes(x = dat, metric = "euclidian",method = "ward")
result
# k-means法の計算
result <- agnes(x = dat, metric = "euclidian",method = "ward")
summary(result)
# 階層クラスタリングの計算
result <- agnes(x = dat, metric = "euclidian",method = "ward")
par(family = "ヒラギノ角ゴシック W3")    # Macユーザーのみ実行
dend <- as.dendrogram(result)    # クラスタリング結果をデンドログラムに書きなおす。
labels(dend) <- row.names(dat)   # デンドログラムにラベルを付ける。
plot(dend, main = "乳製品の消費量")
# 作ったクラスターを可視化する（クラスター数k = 4と決めた場合）
dend <- color_branches(dend, k = 4)
plot(dend)
# 作ったクラスターを可視化する（クラスター数k = 4と決めた場合）
par(family = "ヒラギノ角ゴシック W3")
dend <- color_branches(dend, k = 4)
plot(dend)
str(dend)
dend
# 作ったクラスターの様子を数値要約する。
clusters <- cutree(dend, k = 2)    # クラスターのラベルを計算する。
dat$clusters <- clusters
dat[cluster == 1, ]
# 作ったクラスターの様子を数値要約する。
clusters <- cutree(dend, k = 2)    # クラスターのラベルを計算する。
dat[clusters == 1, ]
dat <- read.csv("./data/dairy_products.csv",
fileEncoding = "utf-8",     # WindowsではUTF-8-BOM
row.names = "country")
head(dat, n = 5)
# 作ったクラスターの様子を数値要約する。
clusters <- cutree(dend, k = 2)    # クラスターのラベルを計算する。
dat[clusters == 1, ]
plot(dat, col = clusters)
# 作ったクラスターの様子を確認する。
clusters <- cutree(dend, k = 4)    # クラスターのラベルを計算する。
dat[clusters == 1, ]
# 最短距離法の計算
res <- agnes(x = data_values, metric = "euclidean", method = "single")
# 最短距離法の計算
res <- agnes(x = data_scaled, metric = "euclidean", method = "single")
# 最短距離法の計算
result <- agnes(x = dat_scaled, metric = "euclidean", method = "single")
dat_scaled <- scale(dat)
# 最短距離法の計算
result <- agnes(x = dat_scaled, metric = "euclidean", method = "single")
# デンドログラム：クラスタリング結果の可視化
dend <- as.dendrogram(res)    # クラスタリング結果をデンドログラムに書きなおす。
# 最短距離法の計算
result <- agnes(x = dat_scaled, metric = "euclidean", method = "single")
# デンドログラム：クラスタリング結果の可視化
dend <- as.dendrogram(res;ut)    # クラスタリング結果をデンドログラムに書きなおす。
# 最短距離法の計算
result <- agnes(x = dat_scaled, metric = "euclidean", method = "single")
# デンドログラム：クラスタリング結果の可視化
dend <- as.dendrogram(reslut)    # クラスタリング結果をデンドログラムに書きなおす。
# 最短距離法の計算
result <- agnes(x = dat_scaled, metric = "euclidean", method = "single")
# デンドログラム：クラスタリング結果の可視化
dend <- as.dendrogram(result)    # クラスタリング結果をデンドログラムに書きなおす。
labels(dend) <- row.names(dat)    # デンドログラムにラベルを付ける。
plot(dend, main = "乳製品の消費量")
# 最短距離法の計算
result <- agnes(x = dat_scaled, metric = "euclidean", method = "single")
# デンドログラム：クラスタリング結果の可視化
dend <- as.dendrogram(result)    # クラスタリング結果をデンドログラムに書きなおす。
labels(dend) <- row.names(dat)    # デンドログラムにラベルを付ける。
par(famly = "ヒラギノ角ゴシック W3")
plot(dend, main = "乳製品の消費量")
# 最短距離法の計算
result <- agnes(x = dat_scaled, metric = "euclidean", method = "single")
# デンドログラム：クラスタリング結果の可視化
dend <- as.dendrogram(result)    # クラスタリング結果をデンドログラムに書きなおす。
labels(dend) <- row.names(dat)    # デンドログラムにラベルを付ける。
par(family = "ヒラギノ角ゴシック W3")
plot(dend, main = "乳製品の消費量")
?agnes
# 重心法の計算
result <- agnes(x = dat_scaled, metric = "euclidean", method = "average")
# デンドログラム：クラスタリング結果の可視化
dend <- as.dendrogram(result)    # クラスタリング結果をデンドログラムに書きなおす。
labels(dend) <- row.names(dat)    # デンドログラムにラベルを付ける。
par(family = "ヒラギノ角ゴシック W3")
plot(dend, main = "乳製品の消費量")
1.73/2
setwd("~/Desktop/すうがくぶんか/集団授業/続初級統計学_改訂/lecture11")
# 必要なライブラリのロード
library(cluster)
library(dendextend)
dat <- read.csv("./data/dairy_products.csv",
fileEncoding = "utf-8",     # WindowsではUTF-8-BOM
row.names = "country")
head(dat, n = 5)
plot(dat)
dat_scaled <- scale(dat)
# 階層クラスタリングの計算
result <- agnes(x = dat_scaled, metric = "euclidian",method = "ward")
par(family = "ヒラギノ角ゴシック W3")    # Macユーザーのみ実行
dend <- as.dendrogram(result)    # クラスタリング結果をデンドログラムに書きなおす。
labels(dend) <- row.names(dat)   # デンドログラムにラベルを付ける。
plot(dend, main = "乳製品の消費量")
# 作ったクラスターを可視化する（クラスター数k = 4と決めた場合）
par(family = "ヒラギノ角ゴシック W3")
dend <- color_branches(dend, k = 4)
plot(dend)
# 作ったクラスターの様子を確認する。
clusters <- cutree(dend, k = 4)    # クラスターのラベルを計算する。
dat[clusters == 1, ]
plot(dat, col = clusters)
# 最短距離法の計算
result <- agnes(x = dat_scaled, metric = "euclidean", method = "single")
# デンドログラム：クラスタリング結果の可視化
dend <- as.dendrogram(result)    # クラスタリング結果をデンドログラムに書きなおす。
labels(dend) <- row.names(dat)    # デンドログラムにラベルを付ける。
par(family = "ヒラギノ角ゴシック W3")
plot(dend, main = "乳製品の消費量")
