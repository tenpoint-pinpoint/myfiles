# 予測値
predict(result, data = dat[1, ])
?predict.nnet
# 予測値
predict(result, newdata = dat[1, ])
# 予測値
predict(result, newdata = dat[1, ], type = "raw")
# 予測値
predict(result, newdata = dat[1, ], type = "prob")
predict(result, newdata = dat[1, ], type = "class")
# ライブラリの読み込み
library(nnet)    # neural network
# 有名なあやめのデータでちょっとデモをしてみましょう。
data(iris)
dat <- iris
head(dat, n = 5)    # 説明変数は4つ。
table(dat$Species)    # 目的変数は多クラス（3クラス）
# 多項ロジスティック回帰
result <- multinom(Species ~ ., data = dat)
summary(result)
# 予測値
predict(result, newdata = dat[1, ], type = "prob")
dat[1, ]
predict(result, newdata = dat[1, ], type = "class")
View(iris)
# 標準化したデータの分散共分散行列
X_scaled <- scale(dat[, 2:4])
# データの読み込み
dat <- read.csv("./data/ramen.csv", fileEncoding = "cp932")
dat
# 標準化したデータの分散共分散行列
X_scaled <- scale(dat[, 2:4])
covmat_scaled <- cov(X_scaled)
covmat_scaled
# 相関行列
X <- dat[, 2:4]
cormat <- cor(X)
cormat
# 相関行列の固有値分解
result <- eigen(cormat)
result
cormat%*%result$vectors[,1]
result$values[1]%*%result$vectors[,1]
# 寄与率の計算
result$values[1,2] / sum(result$values)
# 寄与率の計算
result$values[c(1,2)] / sum(result$values)
# 主成分得点
X_scaled <- scaled(dat[, 2:4])
# 主成分得点
X_scaled <- scale(dat[, 2:4])
X_scaled %*% result$vectors[1:2]
X_scaled
result$vectors[1:2]
# 主成分得点
X_scaled <- scale(dat[, 2:4])
X_scaled %*% result$vectors[ ,1:2]
# データの読み込み
dat <- read.csv("./data/ramen.csv", fileEncoding = "cp932", index = "店名")
?read.csv
# データの読み込み
dat <- read.csv("./data/ramen.csv", fileEncoding = "cp932", row.names = "店名")
dat
# 標準化したデータの分散共分散行列
X_scaled <- scale(dat)
covmat_scaled <- cov(X_scaled)
covmat_scaled
# 相関行列
cormat <- cor(dat)
cormat
# 相関行列の固有値分解
result <- eigen(cormat)
result
# 寄与率の計算
result$values[1:2] / sum(result$values)
# 主成分得点
X_scaled <- scale(dat)
X_scaled %*% result$vectors[ ,1:2]
?prcomp
# prcompによる主成分分析
result <- prcomp(dat, scale. TRUE)
# prcompによる主成分分析
result <- prcomp(dat, scale. = TRUE)
result
# 主成分得点
result$x
# 寄与率の計算
result$values / sum(result$values)
# 主成分得点
X_scaled <- scale(dat)
X_scaled %*% result$vectors
# 相関行列の固有値分解
result <- eigen(cormat)
result
# 寄与率の計算
result$values / sum(result$values)
# 主成分得点
X_scaled <- scale(dat)
X_scaled %*% result$vectors
# prcompによる主成分分析
result <- prcomp(dat, scale. = TRUE)
result
# 主成分得点
result$x
0.57*sqrt(1.25)
0.52*sqrt(1.25)
0.63*sqrt(1.25)
# 麺と第1主成分の相関係数
cor(dat$麺, result$x[, 1])
0.57*1.25
0.52*1.25
0.63*1.25
# 麺と第1主成分の相関係数
cor(dat$麺, result$x)
# 麺と第1主成分の相関係数
cor(dat, result$x[, 1])
# 麺と主成分の相関係数
cor(dat, result$x)
?biplot
biplot(result)
par(family = "ヒラギノ角ゴシック")    # Macユーザーのみ
biplot(result)
par(family = "ヒラギノ角ゴシック W3")    # Macのみ
biplot(result)
pacf(HAKUSAN[,1])
data(HAKUSAN)
pacf(HAKUSAN[,1])
library(TSSS)
data(HAKUSAN)
pacf(HAKUSAN[,1])
result <- pacf(HAKUSAN[,1])
str(result)
result$acf
ar(HAKUSAN[,1])
ar(HAKUSAN[,1], p = 1)
?ar
ar(HAKUSAN[,1], order.max = 1)
ar(HAKUSAN[,1], order.max = 2)
ar(HAKUSAN[,1], order.max = 3)
ar(HAKUSAN[,1], order.max = 1)
result$acf
data(HAKUSAN)
result_pacf <- pacf(HAKUSAN[,1])
result_pacf$acf
ar(HAKUSAN[,1], order.max = 1)
result_pacf$acf[1:3]
result_acf <- acf(HAKUSAN[,1])
result_acf[1:3]
ar(HAKUSAN[,1], order.max = 2)
?acf
result_acf <- acf(HAKUSAN[,1], type = "correlation")
result_acf[1:3]
result_acf <- acf(HAKUSAN[,1])
result_acf[1:3]
result_acf <- acf(HAKUSAN[,1])
result_acf[1:3]
?acf
covmat <- matrix(c(1, 0.718, 0.718, 1), ncol = 2)
solve(covmat) %*% c(0.718, 0.112)
ar(HAKUSAN[,1], order.max = 2)
ar(HAKUSAN[,1], order.max = 3)
result_acf <- acf(HAKUSAN[,1])
result_acf[1:3]
result_acf <- acf(HAKUSAN[,1])
result_acf[1:3]
result_acf[1:4]
solve(covmat) %*% c(0.718, 0.112, -0.555)
covmat <- matrix(c(1    ,  0.718,  0.112,
0.718,  1    , -0.397,
0.112, -0.397, 1    ), ncol = 3)
solve(covmat) %*% c(0.718, 0.112, -0.555)
ar(HAKUSAN[,1], order.max = 3)
covmat <- matrix(c(1    , 0.718, -0.397,
0.718, 1    ,  0.718,
-0.397, 0.718,  1   ), ncol = 3)
solve(covmat) %*% c(0.718, 0.112, -0.555)
ar(HAKUSAN[,1], order.max = 3)
solve(covmat) %*% c(0.718, 0.112, -0.397)
ar(HAKUSAN[,1], order.max = 3)
result_acf[1:4]
solve(covmat) %*% c(0.112, -0.397, -0.555)
ar(HAKUSAN[,1], order.max = 3)
result_acf[1:3]
covmat <- matrix(c(1    , 0.112, -0.397,
0.112, 1    ,  0.112,
-0.397, 0.112,  1   ), ncol = 3)
solve(covmat) %*% c(0.718, 0.112, -0.397)
ar(HAKUSAN[,1], order.max = 3)
covmat <- matrix(c(1    , 0.718, 0.112,
0.718, 1    , 0.718,
0.112, 0.718, 1   ), ncol = 3)
solve(covmat) %*% c(0.718, 0.112, -0.397)
ar(HAKUSAN[,1], order.max = 3)
# 相関行列
cormat <- diag(c(1, 1, 1))
cormat
# 固有値分解
eigen(cormat)
mtcars
dat <- read.csv("mtcars_numeric.csv",
fileEncoding = "utf-8",
row.names = "model")
dat <- read.csv("./data/mtcars_numeric.csv",
fileEncoding = "utf-8",
row.names = "model")
result <- prcomp(dat, scale. = TRUE)
biplot(result)
dat <- read.csv("./data/mtcars_numeric.csv",
fileEncoding = "utf-8",
row.names = "model")
result <- prcomp(dat, scale. = TRUE)
result
dat <- read.csv("./data/mtcars_numeric.csv",
fileEncoding = "utf-8",
row.names = "model")
cor(dat)
result <- prcomp(dat, scale. = TRUE)
result
biplot(result)
?par
par(width = 10, height = 10)
biplot(result)
window(width = 10, height = 10)
windows(width = 10, height = 10)
par(ps = 18)
biplot(result)
par(ps = 6)
biplot(result)
par(ps = 9)
biplot(result)
par(ps = 8)
biplot(result)
install.packages("corrplot")
# ヒートマップをかくためのパッケージの読み込み
# install.packages("corrplot")
library(corrplot)
dat <- read.csv("./data/mtcars_numeric.csv",
fileEncoding = "utf-8",
row.names = "model")
corrplot(dat)
dat
dat <- read.csv("./data/mtcars_numeric.csv",
fileEncoding = "utf-8",
row.names = "model")
cormat <- cor(dat)    # 相関行列の計算
corrplot(cormat)    # ヒートマップの作成
?prcomp
result <- prcomp(dat, scale. = TRUE, rank. = 2)
result
result <- prcomp(dat, scale. = TRUE, rank. = 2)    # rankは使う主成分の数
result
3*var(1/sqrt(2),1/sqrt(2),-1/sqrt(2),-1/sqrt(2))/4
3*var(c(1/sqrt(2),1/sqrt(2),-1/sqrt(2),-1/sqrt(2))/4
)
3*var(c(1/sqrt(2),1/sqrt(2),-1/sqrt(2),-1/sqrt(2)))/4
3*var(c(1,1,0,0))/4
?varimax
x <- matrix(c(1/sqrt(2), 1/sqrt(2),
1/sqrt(2), 1/sqrt(2),
1/sqrt(2), -1/sqrt(2),
1/sqrt(2), -1/sqrt(2)), ncol = 2)
x
varimax(x)
x <- matrix(c(1/2, 1/2,
1/2, 1/2,
1/2, -1/2,
1/2, -1/2), ncol = 2)
varimax(x)
x <- matrix(c(1, 0,
1, 0,
0, 1,
0, 1), ncol = 2)
varimax(x)
varimax
x <- matrix(c(3/4, 1/2,
1/2, 1/2,
3/4, 0,
1/2, 0), ncol = 2)
varimax(x)
x <- matrix(c(3/4, 1/2,
1/2, -1/2,
3/4, 0,
1/2, 0), ncol = 2)
varimax(x)
print(varimax(x), cutoff = 0)
x
x <- matrix(c(3/4, 1/2,
1/2, -1/2,
3/4, 0,
1/2, 0), ncol = 2, byrow = TRUE)
x
varimax(x)
x <- matrix(c(1/2, 1/2,
1/2, 1/2,
1/2, -1/2,
1/2, -1/2), ncol = 2, byrow = TRUE)
varimax(x)
x <- matrix(c(3/4, 2/4,
2/4, 2/4,
3/4, -2/4,
3/4, -2/4), ncol = 2, byrow = TRUE)
varimax(x)
# 正規化して分散の和を求める
rowSum(x^2)
# 正規化して分散の和を求める
rowSums(x^2)
# 正規化して分散の和を求める
rowSums(x^2)
div <- matrix(c(rowSums(x^2), rowSums(x^2)), ncol = 2)
div
x_scaled
x_scaled <- x^2/div
x_scaled
apply(x_scaled, 1, var)
apply(x_scaled, 2, var)
sum(apply(x_scaled, 2, var))
# 因子負荷行列の例 : 単純構造の場合の例
x <- varimax(x)
x
print(x, cutoff = 0)
# 正規化して分散の和を求める
rowSums(x^2)
div <- matrix(c(rowSums(x^2), rowSums(x^2)), ncol = 2)
# 正規化して分散の和を求める
x <- x$loadings
rowSums(x^2)
div <- matrix(c(rowSums(x^2), rowSums(x^2)), ncol = 2)
div
x_scaled <- x^2/div
x_scaled
apply(x_scaled, 2, var)
sum(apply(x_scaled, 2, var))
print(x_scaled, cutoff = 0)
apply(x_scaled, 2, var)
sum(apply(x_scaled, 2, var))
?varimax
varimax
setwd("~/Desktop/すうがくぶんか/集団授業/続初級統計学_改訂/lecture12")
?select
?filter
data(iris)    # irisデータの読み込み
dat <- iris[iris$Species %in% c("versicolor", "virginiva"),
c("Petal.Length", "Petal.Width", "Species")]
head(dat, n = 5)
plot(dat, col = dat$Species)
tail(iris)
# デモデータセットの作成
data(iris)    # irisデータの読み込み
dat <- iris[iris$Species %in% c("versicolor", "virginica"),
c("Petal.Length", "Petal.Width", "Species")]
head(dat, n = 5)
plot(dat, col = dat$Species)
result <- lda(Species ~ Petal.Length + Petal.Width, data = dat)
library(MASS)
result <- lda(Species ~ Petal.Length + Petal.Width, data = dat)
summary(result)
library(MASS)
result <- lda(Species ~ Petal.Length + Petal.Width, data = dat)
result
str(result)
library(MASS)
result <- lda(Species ~ Petal.Length + Petal.Width, data = dat)
result$scaling
levels(dat$Species)
# デモデータセットの作成
data(iris)    # irisデータの読み込み
dat <- iris[iris$Species %in% c("versicolor", "virginica"),
c("Petal.Length", "Petal.Width", "Species")]
levels(dat$Species) <- c("versicolor", "virginica")
# デモデータセットの作成
data(iris)    # irisデータの読み込み
dat <- iris[iris$Species %in% c("versicolor", "virginica"),
c("Petal.Length", "Petal.Width", "Species")]
head(dat, n = 5)
library(MASS)
result <- lda(Species ~ Petal.Length + Petal.Width, data = dat)
result$scaling
library(MASS)
result <- lda(Species ~ Petal.Length + Petal.Width, data = dat)
# デモデータセットの作成
data(iris)    # irisデータの読み込み
dat <- iris[iris$Species %in% c("versicolor", "virginica"),
c("Petal.Length", "Petal.Width", "Species")]
dat$Species <- as.character(dat$Species)
head(dat, n = 5)
plot(dat, col = dat$Species)
# デモデータセットの作成
data(iris)    # irisデータの読み込み
dat <- iris[iris$Species %in% c("versicolor", "virginica"),
c("Petal.Length", "Petal.Width", "Species")]
dat$Species <- factor(dat$Species, levels = c("versicolor", "virginica"))
head(dat, n = 5)
plot(dat, col = dat$Species)
library(MASS)
result <- lda(Species ~ Petal.Length + Petal.Width, data = dat)
library(MASS)
result <- lda(Species ~ Petal.Length + Petal.Width, data = dat)
result$scaling
str(result)
plot(result)
sum(result$scaling * dat[, c("Petal.Length", "Petal.Width")])
sum(result$scaling * dat[1 , c("Petal.Length", "Petal.Width")])
result$scaling
result$scaling * dat[1, c("Petal.Length", "Petal.Width")]
dat[1, c("Petal.Length", "Petal.Width")
]
plot(dat)
plot(result)
?aggregate
aggregate(Species ~., dat, mean)
aggregate(.~ Species, dat, mean)
# 説明変数の群平均
group_mean <- aggregate(.~ Species, dat, mean)
group_mean
# 群平均から計算される各群の判別得点平均値
group_mean %*% result$scaling
group_mean
as.matrix(group_mean)
# 群平均から計算される各群の判別得点平均値
as.matrix(group_mean[, c("Petal.Length, Petal.Width")]) %*% result$scaling
as.matrix(group_mean[, c("Petal.Length, Petal.Width")])
# 群平均から計算される各群の判別得点平均値
as.matrix(group_mean[, c("Petal.Length", "Petal.Width")]) %*% result$scaling
mean(result$scaling)
# 群平均から計算される各群の判別得点平均値
group_center <- as.matrix(group_mean[, c("Petal.Length", "Petal.Width")]) %*% result$scaling
group_center
mean(group_center)
pred <- predict(dat[1, c("Petal.Length", "Petal.Width")])
pred <- predict(result, dat[1, c("Petal.Length", "Petal.Width")])
pred$x
pred <- predict(result, dat[1, c("Petal.Length", "Petal.Width")])
pred$x
pred <- predict(result, dat[1, c("Petal.Length", "Petal.Width")])
pred$x
sum(result$scaling * dat[1 , c("Petal.Length", "Petal.Width")]) - mean(group_center)
|id|$x_1$|$x_2$|$y$|
|:-:|:-:|:-:|:-:|
|1|$x_{11}^{(-1)}$|$x_{12}^{(-1)}$|$-1$|
|1|$x_{11}^{(-1)}$|$x_{12}^{(-1)}$|$-1$|
group_mean
# 説明変数の群平均
group_mean <- aggregate(.~ Species, dat, mean)
group_mean
# 説明変数の群平均
group_mean <- aggregate(.~ Species, dat, mean)
group_mean <- group_mean[ , c("Petal.Length", "Petal.Width")]
group_mean
x_diff <- group_mean[1, ] - group_mean[2, ]
SB <- x_diff %*% t(x_diff)
x_diff <- group_mean[1, ] - group_mean[2, ]
x_diff
#SB <- x_diff %*% t(x_diff)
#SB
x_diff <- as.numeric(group_mean[1, ] - group_mean[2, ])
x_diff
#SB <- x_diff %*% t(x_diff)
#SB
x_diff <- as.numeric(group_mean[1, ] - group_mean[2, ])
SB <- x_diff %*% t(x_diff)
SB
Sm <- cov(dat[dat$Species == "versicolor", ])
dat
cov(dat[dat$Species == "versicolor", ])
dat[dat$Species == "versicolor", ]
Sm <- cov(dat[dat$Species == "versicolor", c("Petal.Length", "Petal.Width")])
Sp <- cov(dat[dat$Species == "virginica", c("Petal.Length", "Petal.Width")])
SW <- 1/(100-2) * ((50-1)*Sm + (50-1)*Sp)
SW
eigen(solve(SW)%*%SB))
eigen(solve(SW)%*%SB)
w <- eigen(solve(SW)%*%SB)
w
result$scaling / w$vectors[ , 1]
# デモデータセットの作成
data(iris)    # irisデータの読み込み
dat <- iris[iris$Species %in% c("versicolor", "virginica"),
c("Petal.Length", "Petal.Width", "Species")]
dat$Species <- factor(dat$Species, levels = c("versicolor", "virginica"))
head(dat, n = 5)
plot(dat, col = dat$Species)
library(MASS)
result <- lda(Species ~ Petal.Length + Petal.Width, data = dat)
result$scaling    # w1とw2
sum(result$scaling * dat[1 , c("Petal.Length", "Petal.Width")])
# 説明変数の群平均
group_mean <- aggregate(.~ Species, dat, mean)
group_mean
# 群平均から計算される各群の判別得点平均値
group_center <- as.matrix(group_mean[, c("Petal.Length", "Petal.Width")]) %*% result$scaling
group_center
mean(group_center)
# R言語のpredict関数で計算した判別得点
pred <- predict(result, dat[1, c("Petal.Length", "Petal.Width")])
pred$x
# 解説した内容に沿って計算した判別得点
sum(result$scaling * dat[1 , c("Petal.Length", "Petal.Width")]) - mean(group_center)
# 説明変数の群平均
group_mean <- aggregate(.~ Species, dat, mean)
group_mean <- group_mean[ , c("Petal.Length", "Petal.Width")]
group_mean    # 1行目がversicolor, 2行目がvirginica
# S_Bを計算する。
x_diff <- as.numeric(group_mean[1, ] - group_mean[2, ])
SB <- x_diff %*% t(x_diff)
SB
Sm <- cov(dat[dat$Species == "versicolor", c("Petal.Length", "Petal.Width")])
Sp <- cov(dat[dat$Species == "virginica", c("Petal.Length", "Petal.Width")])
SW <- 1/(100-2) * ((50-1)*Sm + (50-1)*Sp)
SW
w <- eigen(solve(SW)%*%SB)
w
result$scaling / w$vectors[ , 1]
