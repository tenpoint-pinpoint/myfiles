library(tidyverse)
# データを読み込むときに変数型変換方法

# 1、読み込み時に変換する
dat <- read_csv("test.csv",
                col_type = "idcflD") # --> １列目からi,d,c,f,l,Dの順番に強制変換されて読み込む
## i : integer ---> 整数型
## d : double ----> 実数型
## c : caracter --> 文字列型
## f : factor ----> 因子型
## l : logical ---> 論理値型
## D : Date ------> 日付型

# 2、データを読み込んだ後に変換する
dat$x1 <- as.numeric(dat$x1) #------> x1列を数値型に変換して、元のデータ列に上書きしているイメージ
## データフレーム$列名で特定のデータマートの特定列を指定


# 変数型の指定なしver
dat <- read_csv(file = "test.csv")

# 変数型の指定ありver
dat <- read_csv(file = "test.csv", col_types = "ciii")

# 読み込み後の型変換
dat$id <- as.character(dat$id)

# データフレームの行数・列数を数える
dat #--------------> tibble形式の場合、結果の最初に表示される
dim(dat) #---------> 行数、列数の順で取得できる
length(dat) #------> 行ベクトルの長さ＝列数を取得できる
length(dat$id) #---> 列ベクトルの長さ=行数を取得できる


# 横長データを縦長データに変換する（tidy dataにする）　※逆の操作は pivot_wider()
pivot_longer(data = [対象のデータフレーム], 
             cols = [変形対象列名のベクトル],#----> c("x1","x2","x3","x4")　のような形で縦長にまとめたい列を選択
             name_to = [キーとなる列], #----------> 表頭に使われている変数をまとめる列名　デフォではnameとなる
             values_to = [値となる列]) #----------> 値を挿入する列名　デフォではvaluesとなる

# selectのいろいろなやり方
select(x1, x2) #--------------------> 普通に選択
select(x1:x3) #---------------------> x1~x3まで
select(!x4) #-----------------------> x4以外
select(new_name = x1) #-------------> x1を選択し、名前を変えている（名前を変えるだけの場合はrename）
select(starts_with("col_")) #-------> 指定した文字列で始まる列だけを抽出する
select(ends_with("col_")) #---------> 指定した文字列で終わる列だけを抽出する
select(contais("_")) #--------------> 指定した文字列を含む列だけを抽出する
select(where(is.character())) #-----> データ型を指定し、TRUEの列のみを抽出


# mutateのいろいろなやり方
mutate(追加列 = 追加する値, 追加列２ = 追加する値２, …) #----> 通常の追加方法。追加列名を既にある列名にすると上書きする
mutate(追加列 = "1") #---------------------------------------> 全て同じ値の列を追加
mutate(追加列 = c(1:1000)) #---------------------------------> 異なる値を追加する場合は行数をでデータフレームと同じにする
mutate(追加列 = x1 + x2) #-----------------------------------> 既存の列同士を計算した結果を追加する
# ちょっと複雑な追加方法
mutate(追加列 = case_when(条件１ ~ 条件１がTRUEの場合の値,
                          条件２ ~ 条件２がTRUEの場合の値,
                          TRUE ~ どの条件もFALSEの場合の値))


# filterの使い方
filter(列１ = 条件1, 条件2, …) #------------> 通常の使い方
filter(列１ != 条件) #----------------------> 条件以外の行
filter(列１ >= 条件値) #--------------------> 条件以上の行
filter(between(列１, 条件１, 条件２)) #-----> 条件１以上条件２未満の行
filter(列１ %in% c(条件１, 条件２, …)) #----> いずれかの条件と同じ行
filter(!is.na(列１)) #----------------------> 列１に置いてnaではない行


# 行の並べ替え
arrange(列１) #-----------> 列１で昇順になるようにデータフレーム全体が並べ替えられる
arrange(列１, 列２, …) #--> 列１、列２の順に昇順になるようにデータフレーム全体が並べ替えられる
arrange(desc(列１)) #-----> 列１で降順になるようにデータフレーム全体が並べ替えられる


# 文字列の処理,,,stringrパッケージを用いる
str_c(dat$x1, dat$x2, sep = "_") #-------------> x1とx2を連結、間に_を入れる。パッケージ単独で使う場合はdf$colで指定
str_detect(string = dat$x1, pattern = "_") #---> stringで検索対象を指定、patternに指定した文字列を含むかどうかを判断TRUE or FALSE
str_subset(string = dat$x1, pattern = "_") #---> patternで指定した文字列を含む行を抽出
str_replace(string = dat$x1, pattern = "_", 
            replacement = "and") #-------------> patternで指定した箇所をreplacementで指定した文字列に置換
srt_replace_all(string = dat$xa,
                pattern = c("置換対象１" = "置換後１", "置換対象２" = "置換後２")) #--> 複数のパターンを一気に置換する方法
str_trim(string = dat$x1) #--------------------> 左端と右端の空白を削除


# 欠損値の補完
fill(data = dat, [補完したい列名]) #--------------------> 欠損値を１つ前の値で補完する
replace_na(data = dat, 
           replace = list(補完したい列１ = 補完値,…)) #-> 特定の値で補完を行う

# 特定のベクトルを繰り返したベクトルを作る
x <- rep(x = c("10", "20", "30"), times = 3) #---> xに繰り返したいベクトル、timesに繰り返す回数


# データ結合
inner_join(x = dat1, y = dat2, by = "id") #--> 両方にあるやつ
left_join(x = dat1, y = dat2, by = "id") #---> 左優先
right_join(x = dat1, y = dat2, by = "id") #--> 右を優先
full_join(x = dat1, y = dat2, by = "id") #---> どちらかにあるもの（つまり全部）

