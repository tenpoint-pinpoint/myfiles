# データ取込
dat <- read.csv('./sitedata.csv',header=T, fileEncoding = 'utf-8', row.names = 'id')
str(dat)

########################################################################################
# ここからは１つ１つ計算をしていきます。ノートで記載したものと同じようになっています。
########################################################################################

# 標準化
dat_scale <- scale(dat)
dat_scale

# 共分散行列を計算する --> 標準化して共分散行列を計算 = 元データの相関係数
cov_mat_scaled <- cov(dat_scale)
cov_mat_scaled
cor_mat <- cor(dat)#-------------------------> 元データの相関係数を試しに計算
cor_mat #------------------------------------> 相関行列は途中で標準化処理をしてるのでcov_matと一致する

# cor_matに対してeigenで固有値・固有ベクトルを求める = これが主成分の係数
# コンピュータでラグランジュ未定乗数法を実施するのは結構大変なのでこの方法を使う
result <- eigen(cor_mat)
result
#----------------------------------------------------#
#$values    --> 固有値 -> 左から第１主成分の係数ベクトル（固有ベクトル）に対応する固有値
#[1]   1.5955409     0.9885424   0.4159167

#$vectors   --> 固有ベクトル、縦方向に見る -> 第１主成分の係数ベクトルは (-0.70 -0.49 0.50)
#          [,1]       [,2]       [,3]
#[1,] -0.7036643 -0.0005706363  0.7105324
#[2,] -0.4952796  0.7174123081 -0.4899160
#[3,]  0.5094651  0.6966485876  0.5051000
#----------------------------------------------------#

#行列の掛け算
cor_mat %*% result$vectors[,1]  #---------> この式は分散共分散行列と固有ベクトルをかけたもの,ノートでいうとAx
#下記と上記は一致する
result$values[1] * result$vectors[,1] #---> この式は固有値と固有ベクトルをかけたもの、ノートでいうとλx

#実は、主成分の分散は該当する固有値に一致
#固有値が大きい順に第１主成分、第２主成分、第３主成分

#寄与率 = 主成分の分散 / 分散の合計
sum(result$values)#-----------------> 分散の合計、標準化したので変数の個数に一致する。
result$values/sum(result$values)#---> 各主成分の寄与率。元の情報をどの程度持っているかを確認する

result$vectors[,1]# ----> 第１主成分
result$vectors[,2]# ----> 第２主成分
result$vectors[,3]# ----> 第３主成分

#主成分得点の計算 -> 個別のデータを評価するときに使います
X_scale %*% result$vectors


########################################################################################
# 実際にはRでは以下の関数で一髪で主成分分析は完了します。
########################################################################################

#主成分分析関数：prcomp関数
result2 <- prcomp(dat, scale=TRUE)
result2

#--------------------------------------------------------------------#
# Standard deviations (1, .., p=3): --------> 主成分の標準偏差。２乗すると分散になる
#      [1] 1.2631472 0.9942547 0.6449160

# Rotation (n x k) = (3 x 3):  -------------> 主成分係数=固有ベクトル
#                PC1          PC2        PC3
# use     0.7036643 -0.0005706363 -0.7105324
# design  0.4952796  0.7174123081  0.4899160
# price  -0.5094651  0.6966485876 -0.5051000
#--------------------------------------------------------------------#

#biplot -> 主成分の方向と元データの分布を図示する。主成分を解釈する際に有効
par(family = "ヒラギノ角ゴシック W3")
biplot(result2)

#主成分得点
result2$x

#主成分負荷量
cor(dat, result2$x)#-----> 元データと主成分得点の相関
# これによって、各主成分における各変数の影響度合いがわかる
# 元データの情報を保持しているなら元データと相関があるよね、という発想
# 実はこれは、係数と主成分の標準偏差の積に等しい
#--------------------------------------------------------------------#
#              PC1           PC2         PC3
#use     0.8888316 -0.0005673578 -0.4582337
#design  0.6256111  0.7132905718  0.3159547
#price  -0.6435294  0.6926461448 -0.3257471
#--------------------------------------------------------------------#

# おまけ：主成分係数と標準偏差の積 = 固有ベクトルと固有値の平方根の積 = 主成分負荷量
sweep(result2$rotation,#-----> ベクトル、もしくは行列
      MARGIN = 2,#-----------> 1が行方向、２が列方向
      result2$sdev,#---------> 掛ける統計量
      FUN = '*')#------------> 計算方法。+,-,*,/

result2$rotation # 固有ベクトル
result2$sdev     # 固有値


















# mtcarsデータ（Rに元々入ってます）
# 変数が多いので、主成分分析の恩恵を理解しやすいです、やってみてください

mtcars
str(mtcars)

cor(mtcars)
install.packages('corrplot')
library(corrplot)
corrplot(cor(mtcars))
# 相関があることがわかり、主成分分析をする価値のあるデータであることがわかる

#主成分分析をしてみる、今回は第２主成分まで（rankで表示する数を決めることができる）
result3 <- prcomp(mtcars, scale=TRUE, rank. = 2)
result3

result3$sdev**2/11 #----->寄与率
#---------------------------------------
#0.600763659 
#0.240951627
#0.057017934 
#0.024508858 
#0.020313737 
#0.019236011 
#0.012296544
#0.011172858 
#0.007004241
#0.004730495
#0.002004037
#---------------------------------------

par(family = "ヒラギノ角ゴシック W3", ps=6)
biplot(result3)

cor(mtcars, result3$x)
result3$rotation * result3$sdev[1:2]

result3$rotation 
result3$sdev[1:2]